import idc, idaapi, ida_ua
import struct

# set comment in decompiled code
def set_hexrays_comment(address, text):
    cfunc = idaapi.decompile(address)
    tl = idaapi.treeloc_t()
    tl.ea = address
    tl.itp = idaapi.ITP_SEMI
    cfunc.set_user_cmt(tl, text)
    cfunc.save_user_cmts() 

def set_comment(address, text):
    try:
        idc.set_cmt(address, text, 0)
        set_hexrays_comment(address, text)
    except Exception as e:
        print(e)
        return

pattern1 = "3B ?? 04 00 00 00"  # cmp      eax, [reg+4]
pattern2 = "0F 28 05"           # movaps   xmm0, ds:xmmword_??????

# Lowest address used in the program
addr = idc.get_inf_attr(INF_MIN_EA)

while True:
    # Search for pattern1
    addr = ida_search.find_binary(addr, idc.BADADDR, pattern1, 16, ida_search.SEARCH_NEXT | ida_search.SEARCH_DOWN)
    if addr == idc.BADADDR:
        break
    
    ea = addr
    enc_bytes = b''
    comment_addr = idc.BADADDR

    # Search for possible stack strings in the previous 12 instructions
    for i in range(12):
        ea = idc.prev_head(ea)
        if (idc.print_insn_mnem(ea) == "mov" and
            idc.get_operand_type(ea, 0) == idc.o_displ and
            idc.get_operand_type(ea, 1) == idc.o_imm):
            # Get the value of the second operand
            operand_value = idc.get_operand_value(ea, 1)

            # Get the size of the second operand
            insn = ida_ua.insn_t()
            ida_ua.decode_insn(insn, ea)
            operand_size = ida_ua.get_dtype_size(insn.Op2.dtype)

            # Specify the correct data type
            if operand_size == 4:
                operand_bytes = struct.pack("<I", operand_value)
            elif operand_size == 2:
                operand_bytes = struct.pack("<H", operand_value)
            else:
                operand_bytes = struct.pack("<B", operand_value)
            
            # Edgecase_1 (Bad operand value)
            if operand_bytes[-1] == 0x00:
                continue
            # Edgecase_2 (Bad stack offset ebp-4)
            elif idc.get_operand_value(ea, 0) == 0xfffffffc:
                continue

            # Set the comment address for the decrypted string
            comment_addr = ea

            enc_bytes = operand_bytes + enc_bytes


    # Find possible xmmword movaps
    xmmword_addr = ida_search.find_binary(addr, addr+50, pattern2, 16, ida_search.SEARCH_NEXT | ida_search.SEARCH_DOWN)
    if xmmword_addr != idc.BADADDR:
        # Read the xmmword value
        xmmword_value = idc.get_bytes(get_operand_value(xmmword_addr, 1), 16)
        enc_bytes = xmmword_value + enc_bytes

        # Assign comment address if not assigned yet
        if comment_addr == idc.BADADDR:
            comment_addr = xmmword_addr

    # Decrypt and strip encrypted bytes
    dec_bytes = bytes(c ^ 0x2E for c in enc_bytes)
    dec_str = dec_bytes.strip(b'\x00').decode('utf-8')
   
    if len(dec_str) != 0:
        print(f"{hex(addr)} --> {dec_str}")
    
        # Set a comment with the decrypted string
        if dec_str and comment_addr != idc.BADADDR:
            set_comment(comment_addr, dec_str)
