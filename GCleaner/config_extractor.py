import sys
import pefile
import struct, re
from capstone import *
from capstone.x86 import *

pattern1 = b"\x3B.\x04\x00\x00\x00"  # cmp      eax, [reg+4]
pattern2 = b"\x0F\\x28\x05"          # movaps   xmm0, ds:xmmword_??????

if len(sys.argv) < 2:
    exit("Usage: config_extractor.py filename")

pe = pefile.PE(sys.argv[1])

# Initialize Capstone
md = Cs(CS_ARCH_X86, CS_MODE_32)
md.skipdata = True
md.detail = True

# Find .text section
insns = []
text_section = pe.sections[0]
text_section_addr = pe.OPTIONAL_HEADER.ImageBase + text_section.VirtualAddress

# Disassemble .text section
for insn in md.disasm(text_section.get_data(), text_section_addr):
    insns.append(insn)

dec_strs = []
for i in range(len(insns)):
    if re.match(pattern1, insns[i].bytes):
        enc_bytes = b''
        # Search for possible stack strings in the previous 12 instructions
        for j in range(12):
            insn = insns[i-j-1]
            if (insn.mnemonic == "mov" and
                insn.operands[0].type == X86_OP_MEM and
                insn.operands[1].type == X86_OP_IMM):
                # Get the value and size of the second operand
                operand_value = insn.operands[1].imm
                operand_size = insn.operands[1].size

                # Specify the correct data type
                if operand_size == 4:
                    operand_bytes = struct.pack("<I", operand_value)
                elif operand_size == 2:
                    operand_bytes = struct.pack("<H", operand_value)
                else:
                    operand_bytes = struct.pack("<B", operand_value)

                # Edgecase_1 (Bad operand value)
                if operand_bytes[-1] == 0x00:
                    continue
                # Edgecase_2 (Bad stack offset ebp-4)
                elif insn.operands[0].mem.disp == -4:
                    continue

                enc_bytes = operand_bytes + enc_bytes

        # Find possible xmmword movaps
        for j in range(12):
            if re.match(pattern2, insns[i+j+1].bytes):
                # Get xmmword addr
                xmmword_addr = insns[i+j+1].operands[1].mem.disp
                # VA to RVA
                xmmword_addr -= pe.OPTIONAL_HEADER.ImageBase
                # Read xmmword value
                xmmword_value = pe.get_data(xmmword_addr, 16)

                enc_bytes = xmmword_value + enc_bytes
                break

        # Decrypt and strip encrypted bytes
        dec_bytes = bytes(c ^ 0x2E for c in enc_bytes)
        dec_str = dec_bytes.strip(b'\x00').decode('utf-8')

        if len(dec_str) != 0:
            dec_strs.append(dec_str)

# Regex for C2 addrs and paths
c2_list = []
path_list = []
re_c2 = re.compile(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}")
re_path = re.compile(r"/[\w/]+\.php")

# Match Regex against decrypted strings list
for s in dec_strs:
    # Find C2 addrs
    match = re.search(re_c2, s)
    if match:
        c2_list.append(match.group())

    # Find C2 paths
    match = re.search(re_path, s)
    if match:
        path_list.append(match.group())

# Print config
if len(c2_list) == len(path_list) == 4:
    path_list.append(path_list.pop(0))

    print(f"C2 list:     {c2_list}")
    print(f"Path list:   {path_list}")
    print(f"Stream:      {dec_strs[4]}")
    print(f"SubStream:   {dec_strs[5]}")
    print(f"UserAgent:   {dec_strs[6]}")
